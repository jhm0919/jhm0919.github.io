# 9주차 정리

* const 변수
  * 변수에 const라는 키워드를 사용하여 상수(constant)의 의미를 갖게 하여 그 내용을 변경할 수 없게 한다. 
    - #define IN 10  // 전처리기로 컴파일 전에 IN을 10로 변경
    - const int x=1; // 변수 x는 항상 초기값 1, 변경 불가
  * 반드시 초기값 필요함
    -  int const y=1; // 비추, const는 자료형 앞에 씀
    - const int z{1}; // Uniform initialization, C++11
  * z{}라고 쓰면 자동으로 0으로 초기화
    - constexpr int a = 5; // C++11부터 가능, compile -time constant

​        

* 함수에 사용하는 const
  - 함수 선언시 함수, 매개변수, 리턴형에 const를 선언하여, 이들이 읽기 전용(read only)임을 나타낸다.
    - void func(const int); //매개변수가 const
    - const double func(int); //리턴값이 const, reference(&)를 리턴하는 경우
    - void fun(void) const; //함수가 const, 멤버변수를 변경하지 않는 함수

 

* const 멤버
  - const형 멤버함수는 해당 멤버변수를 변경하는 치환 (replacement)연산을 수행할 수 없다.
  - const로 지정된 함수에서는 멤버변수의 값을 변경할 수 없다. 
    - 즉, 멤버를 참조만 하는 읽기 전용 함수(앞에서 get으로 시작하는 함수)가 된다. 
  - const함수는 const함수만 호출할 수 있으며 일반 멤버함수에는 접근할 수 없다.  
    - 일반 멤버함수에 접근하여 간접적으로 멤버변수를 변경하는 것을 막기 위해
  - 생성자와 소멸자에서는 const를 사용할 수 없다. 
  - const형을 선언하고자 하면 멤버변수는 형 앞에 const를, 멤버함수는 함수의 괄호 다음에 const를 추가한다. 
    - const int age; //멤버변수는 형 앞에
    - int getAge() const; //멤버함수는 괄호 다음에

​    

* const형 멤버변수와 멤버함수

```c++
class 클래스명
{
 const 형 멤버변수; // const 형 멤버변수
 리턴형 함수명(매개변수 리스트) const; // const 형 멤버함수
 :
};
class Dog
{
 const int age; // 멤버변수는 형 앞에 const를 추가
 int getAge() const; // 멤버함수는 괄호 다음에 const를 추가
 :
};
int Dog::getAge() const // 멤버함수는 괄호 다음에 const를 추가
{
 return age;
}
```

   

​    

* 실습 5 -1: const형 멤버함수 과제

```c++
#include <iostream>
class Dog {
 int age; //private 생략함
public:
 int getAge() const
 {
  view(); // 오류 ①
  return age; // 오류 ②
 }
 void setAge(int a) { age = a; }
 void view() const
 {
  std::cout << "나는 view";
 }
};
int main()
{
 Dog happy;
 happy.setAge(5);
 std::cout << happy.getAge();
 return 0;
}
```



​    

* const 객체
  - 객체가 const로 지정되면 해당 객체에 초기화된 데이터는 변경할 수 없으며 const로 지정된 멤버함수만 호출할 수 있다. 
  - 객체를 const로 지정하려면 객체 정의시 클래스 명 앞에 const를 추가한다. 
  - const Dog happy; 
    - const 객체 happy
    - happy의 초기화된 데이터를 변경할 수 없다.



​    

* 실습 5 -2: const 객체 예  

```c++
#include <iostream>
class Dog {
 int age;
public:
 Dog(int a) { age = a; }
 int getAge() const;
 void setAge(int a) { age = a; }
 void view() const
 {
  std::cout << "나는 view\n";
 }
};
int Dog::getAge() const
{
 view();
 return (age);
}
int main()
{
 const Dog happy(5); //const 객체
 std::cout << happy.getAge();
 return 0;
}
```

​    

​    

* 포인터 개요
  - 포인터(pointer)는 C/C++ 언어를 다른 언어와 차별화시키는 가장 큰 특징
  - 포인터를 이용하게 되면 기계어나 어셈블리 언어처럼 메모리의 주소를 이용해 메모리의 내용을 직접 접근할 수 있음
  - 포인터가 사용되는 경우
    - call by reference로 함수로부터 한 개 이상의 값을 리턴할 때
    - 함수들 간에 배열이나 문자열을 전달할 때
    - 배열 조작을 쉽게 할 때
    - 연결 리스트(linked list)나 이진트리(binary tree) 등 복잡한 자료 구조를 만들 때
    - 메모리를 동적으로 할당할 때
  - ```int *pi=(int*)malloc(100*sizeof(int)); //C```
  - ```int *pi=new int[100]; //C++```

​     

​    

* 포인터와 주소
  - 메모리에는 위치를 구분하기 위해 순서대로 번호가 붙어있는데 이것을 메모리의 주소, 번지, address라 함
  - int sum=0;
    - 변수를 초기화하면서 선언하면, int형이므로 4바이트 메모리 공간이 확보되고 초기값으로 0이 할당됨
    - sum변수가 실제로 할당된 메모리의 주소를 알고 싶다면 &연산자를 사용하여 &sum이라고 하면 변수가 기억되어 있는 메모리 번지를 알 수 있음
  - 메모리의 주소를 저장하려면 일반 변수가 아닌 포인터를 사용
  - 포인터라고만 해도 되지만 주소를 저장하는 변수이므로 포인터 변수라고도 함

​    

* 포인터 선언

 \- 포인터도 변수이므로 사용하기 전에 선언해야 함

 \- 자료형과 변수명 사이에 구두점 *를 더 쓰면 됨

 \- 선언문에서 쓰는 *는 곱하기 연산자와 전혀 관계없는 구두점

  · int x; //일반 변수 x의 선언

  · int *x; //포인터 (변수) x의 선언

  · int* px; //포인터 px의 선언

  · int *px, y; //px만 포인터, y는 일반 변수

  · int *px, *py; //px, py 둘 다 포인터

 \- *는 자료형과 변수명 사이 아무데나 있어도 됨

  · int* px; //선언문에서 쓰는 *는 구두점으로 포인터를 선언

  · int * px; 

  · int *px;

​    

​    

* 참조 연산자 *

 \- 포인터에 주소를 대입하는 방법

  · int x=10 ; //일반 변수 x의 선언과 초기화

  px=&x; //포인터 px에 변수 x의 주소 대입

 \- 포인터는 일반적으로 일반 변수명 앞에 주소 연산자(&)를 사용해 해당 변수의 주소를 저장

 \- 포인터 px에는 변수 x의 주소가 들어있음

 \- px가 저장하고 있는 x의 주소로 가서 그 값인 10을 변수 y에 대입하려면 다음과 같이 하면 됨

  · y=*px;

  · 실행문에서 사용하는 *는 참조 연산자, 포인터의 주소로 가서 값을 가져옴

 \- 포인터 앞에 *를 찍어주면 되는데 이때 *는 참조 연산자

 \- 곱하기 연산자 *와 모양은 같지만 우선 순위가 높음

​    

​    

* *: 선언문(구두점) vs. 실행문(연산자)
  - 선언문: 포인터를 선언(구두점)할 때
  - 실행문: 주소로 가서 값을 가져올 때(연산자)
  - *이 선언문에서 사용되는지 실행문에서 사용되는지에 따라서 다름
    - int x=10,y;// 정수형 변수 x,y선언
    - int *px; // 포인터 px선언, 선언문에서 *는 포인터를 선언하는 구두점
    - px=&x; // 정수형 변수 x의 주소를 포인터 px에 대입
    - y=*px; // px가 저장하고 있는 주소로 가서 값을 가져옴
    - // 실행문에서 *는 참조 연산자
  - 실행문에서 *는 포인터 변수에 저장된 주소로 가서 실제 데이터 값을 가져오는데 사용하는 참조 연산자로 간접 값(indirect value) 연산자, dereferencing 연산자라고도 함
  - px에 저장된 주소(&x)로 가서 값(x의 내용)을 가져오므로 y에는 10이 대입됨
  - *px=20; //x=20; 
    - 포인터 px가 가리키는 주소에 20을 대입
    - px가 x의 주소를 가지고 있으므로 변수 x의 값도 바뀜
    - 주소로 가서 값을 바꾸는 간접적인 방법으로 변경

   

​    

* 포인터(변수)의 크기, 선언, 간접 값 참조

```c++
#include <iostream>
int main(void)
{
 int x = 10, y;
 int* px; // 선언문, 포인터 px선언
 px = &x; // 포인터 px에 x의 주소 대입
 y = *px; // 실행문, px의 주소로 가서 값을 가져옴
 std::cout << x << " " << &x << std::endl;
 std::cout << sizeof(x) << " " << sizeof(&x) << std::endl;
 std::cout << px << " " << &px << " " << *px << std::endl;
 std::cout << y << " " << &y;
 return 0;
}
```

​    

​    

* 포인터 변수의 크기
  - Visual Studio는 기본적으로 4바이트이고 8바이트로 변경 가능
  - Dev -C++은 8바이트
  - 대부분의 온라인 컴파일러는 8바이트
  - 컴파일러에서 target을 32bit로 지정하여 빌드하면 4byte(32bit), 64bit로 지정하면 8byte(64bit)



​    

* 포인터의 자료형과 대입할 수 있는 값

  - int *px; 

  - int는 pa가 int형 데이터를 참조하기 위한 포인터라는 의미

  - pa가 지시하는 곳의 자료형이 int형이기 때문에 int형의 주소(&x)만 대입할 수 있음

    - int x=10; 

       int *px; //int형을 가리키는 포인터 px선언

       px=&x; //정수형 변수 x의 주소를 포인터 px에 대입

  - double형 변수 x의 주소를 px에 대입할 수 없음

    - double x=10.5; 

       int *px; //px가 저장하는 주소에는 int형이 있어요.

       px=&x; //오류

​    

​    

* 포인터의 초기화
  - 자료형 *포인터_변수명=초기화 주소; 
    - int x=10; 
    - int *px=&x; 
    - int *px=1000;
  - 직접 특정 번지 값으로 초기화하는 것은 위험
  - warning C4047: '=': 'int *'의 간접 참조 수준이 'int'과(와) 다릅니다.
  - warning: assignment makes pointer from integer without a cast
  - 정수형 포인터 px를 정수형 변수 x의 주소로 초기화
  - 메모리 관리는 OS가 하는 것으로 프로그래머가 특정 번지를 쓰겠다는 것은 많은 위험을 내포하고 있음
  - 포인터 px가 변수 x의 주소로 초기화된 상태



​    

- 포인터의 선언과 간접 값 참조

```c++
#include <iostream>
int main(void)
{
 int* pi; //정수형 포인터 pi
 char* pc; //문자형 포인터 pc
 double* pd; //배정도형 포인터 pd
 std::cout << sizeof(pi) << " " << sizeof(pc) << " " << sizeof(pd) << std::endl;
 std::cout << sizeof(*pi) << " " << sizeof(*pc) << " " << sizeof(*pd);
 return 0;
}
```



​    

* 포인터 연산

```c++
#include <iostream>
int main(void)
{
 char c;
 int i;
 double d;
 char* pc = &c;
 int* pi = &i;
 double* pd = &d;
 std::cout << (void*)pc << " " << (void*)(pc + 1) << std::endl;
 std::cout << pi << " " << pi + 1 << std::endl;
 std::cout << pd << " " << pd + 1 << std::endl;
 return 0;
}
```

​    

​    

* s[i]==*(s+i)
  - C/C++에서 포인터는 배열과 연관되어 많이 사용됨
  - 다른 언어에서 배열은 반드시 첨자와 함께 사용하지만 C/C++에서는 첨자 없이 배열의 이름만을 사용할 수 있음
  - 배열의 이름은 그 배열의 시작 주소를 저장하는 포인터
  - int s[5]라고 배열을 선언했을 경우 첫 번째 원소는 s[0]이며 마지막 원소는 s[4]
  - 이를 포인터 형식으로 표현하면 *s, *(s+4)
  - 배열의 이름 s는 첫 번째 원소의 주소(&s[0])를 저장하는 포인터이므로 그 곳의 내용을 참조(*s)하면 그 값이 s[0]
  - 일차원 배열에서 이러한 특성을 일반화
    - s ==&s[0], s+1==&s[1], s+2==&s[2],..... 
    - s+i==&s[i] 
    - *(s+i)==*&s[i]==s[i] 

 

​    

​    

* x[i]와 *(x+i)

```c++
#include <iostream>
int main(void)
{
 int x[5] = { 10,20,30,40,50 };
 int i;
 std::cout << "x=" << x << std::endl;
 for (i = 0; i < 5; i++)
  std::cout << &x[i] << "=" << x[i] << ", " << x + i << "=" << *(x + i) << std::endl;
 return 0;
}
```

6 : 배열의 이름 x는 첫 번째 원소 x[0]의 주소

8 : &x[i]와 x+i는 같은 주소이고, x[i]와 *(x+i)는 같은 값

​    

​    

* x[1] == 1[x]

```c++
#include <iostream>
int main(void)
{
 int x[5] = { 10,20,30,40,50 };
 std::cout << x << ":" << *x << x[0] << 0[x] << std::endl;
 std::cout << x + 0 << ":" << *(x + 0) << *(0 + x) << x[0] << 0[x] << std::endl;
 std::cout << x + 1 << ":" << *(x + 1) << *(1 + x) << x[1] << 1[x] << std::endl;
 return 0;
}
```

​    

​    

* 지역(local) 변수와 전역(global) 변수
  - 변수의 유효범위(scope)란 프로그램 내에서 변수가 사용될 수 있는 범위
    -  C/C++에서는 지역(local)과 전역(global) 이라는 개념으로 변수가 사용될 수 있는 범위를 지정
  - 지역 변수는 해당 함수나 블록({ }) 내에서만 사용할 수 있고 전역 변수는 소스 전체에서 사용할 수 있음
  - 지역 변수와 전역 변수는 변수의 선언 위치에 따라서 결정됨
    - 함수나 블록 안에서 변수를 선언하면 그 변수는 지역 변수가 되고, 함수 (보통 main()함수)밖에서 선언하면 전역 변수가 됨

​    

​    

* 전역 변수와 지역 변수

```c++
#include <iostream>
void show1(void);
void show2(void);
int x; //전역 변수
int main(void)
{
 std::cout << "main()에서 x:" << x << std::endl;
 show1();
 std::cout << "show1()호출 후 x:" << x << std::endl;
 show2();
 std::cout << "show2()호출 후 x:" << x << std::endl;
 return 0;
}
void show1(void)
{
 std::cout << "show1()에서 x:" << ++x << std::endl;
}
void show2(void)
{
 int x = 10; //지역 변수
 std::cout << "show2()에서 x:" << x << std::endl; //같은 이름의 전역 변수와 지역 변수가 있을 때는 지역 변수가 우선
}
```

전역 변수는 함수 밖에서 선언하며, 프로그램의 모든 부분에서 사용할 수 있음

데이터 영역을 사용하며 프로그램 실행이 종료될 때까지 값을 유지

실행시 한번 만 초기화하고 초깃값이 주어지지 않으면 0으로 자동 초기화

지역 변수와 중복해서 선언되어 있으면 지역 변수 값이 우선임

​    

​    

* 코드 영역과 데이터 영역
  - C/C++ 프로그램은 소스와 프로그램에서 사용할 데이터로 구성됨
  - 소스는 컴파일과 링킹 과정을 거쳐 기계어로 번역됨
  - 기계어로 번역된 코드는 메모리의 코드(code)영역에 저장됨
    - 코드 영역은 저장된 내용을 읽기만 가능하고 쓰기가 불가능한 메모리 영역
  - 프로그램에서 사용할 변수 등의 데이터는 읽기 쓰기가 가능한 데이터 영역에 저장됨
    - 데이터 영역은 비초기화된 데이터가 저장되는 bss, 초기화된 데이터가 저장되는 데이터 영역으로 나눔
  - 지역 변수는 스택 영역을 사용하고 전역 변수는 데이터 영역을 사용


 

* 컴퓨터의 프로그램 메모리 레이아웃
  - 지역변수
    - 자신의 지역({ }) 내에서만 유효하다.
    - 함수가 반환되면 지역변수는 사라진다.
  - 전역변수
    - 프로그램이 끝날 때까지 값을 유지한다. 
    - 프로그램의 모든 부분에서 접근 가능하다.
    -  이해하기 어렵고 유지보수 어렵다.
  - 동적메모리할당
    - 지역변수인데도 할당 받은 메모리를 해제(delete)하기 전까지 값을 유지



​    

* 동적 메모리를 사용하는 이유
  - 지역 변수는 자신의 지역({ }) 내에서만 유효한데, 전역변수처럼 프로그램이 끝날 때까지 값을 유지하고 싶은 경우
  - 프로그램 작성시(컴파일시)는 필요한 메모리 공간의 크기를 모르겠고, 프로그램을 실행할 때(runtime) 메모리의 양을 결정해야 하는 경우
    - 사용자 입력에 필요한 메모리 공간을 확보하는 경우
  - 지금까지는 프로그램을 실행하기 전에 고정된 크기를 가지도록 변수, 배열, 객체를 선언   · int x[1000]; //크기는 넉넉하게
    - 그러나 지역 변수가 저장되는 스택은 한정되어 있어서 너무 큰 크기는 할당 어려움
  - 스택 공간이 부족하면 stack overflow 오류
  - heap에 할당해야 함
  - 실행 시간에 할당되어 사용되는 메모리 블록
    - heap
  - 동적메모리의 단점
    - 스택보다 느림
    - 동적으로 확보된 기억공간은 기억공간에 이름이 없기 때문에 주소를 사용하므로 포인터에 대한 이해가 필요



​    

​    

* 정적 vs. 동적 메모리 할당
  - 정적 메모리 할당
    - 컴파일시 필요한 메모리 할당
    - 배열 : int array[32]; // 항상128byte 공간 확보
    - 사용하지 않는 메모리까지 충분히 잡아 낭비
    - 너무 큰 메모리는 할당 불가
    - 보통 수 kB까지는 스택 사용, 그 이상은 heap에 할당
    - Visual Studio에서 기본 스택 크기는 1MB
  - 동적 메모리 할당
    - 실행시 필요한 메모리(heap) 할당
    - 필요한 만큼만 잡음
    - 메모리의 주소를 사용(포인터 이용)하여 접근
    - malloc()/free() 사용 // C
    - new/delete사용 // C++
  - new : 메모리 할당, 할당된 메모리 시작주소 리턴됨
  - delete : 할당 받은 메모리 해제

  

​    

* 동적 메모리할당: C vs. C++
  - C에서 동적 메모리 할당을 할 경우 malloc() 함수를 사용
    - 할당된 메모리를 해제하기 위해서 free()함수를 사용
  - 이러한 표준 함수들은 C++에서도 사용할 수 있지만 C++에서는 메모리를 할당하고 해제하는데 더 편리하고 안전한 방법을 사용
  - C++에서는
    - 메모리를 할당할 때 new를 사용
    - 할당된 메모리를 해제할 때 delete를 사용

​    

​    

* new와 delete
  - new는 메모리를 동적으로 할당하고, 할당된 메모리에 대한 주소를 반환하는 연산자이다. 
    - malloc() 함수와 마찬가지로, 요구한 만큼의 메모리가 충분하지 않으면 new는 null포인터를 반환한다.
    - int *pi=new int;
    - int *pi = (int *)malloc(sizeof(int));
  - delete는 free()함수와 마찬가지로, 더 이상 필요 없는 메모리를 해제한다.
    - delete pi;
    - free(pi);
    - 해제하지 않으면 메모리 누수(leak)가 발생하여 다른 프로그램에서도 해당 메모리는 사용하지 못한다.

​    

​    

* new와 delete의 장점
  - new와 delete는 malloc()과 free()에 비해 몇 가지 장점이 있다. 
  - new는 지정된 형의 크기만큼 메모리를 자동적으로 할당해 준다. 
  - 즉, 필요한 메모리 크기를 계산하기 위해 sizeof()와 같은 연산자가 필요 없다.
    -  int *pi=new int;
    - int *pi = (int *)malloc(sizeof(int));
  - new는 지정된 형의 포인터(메모리 시작주소)를 자동적으로 반환한다. 
  - new와 delete는 중첩이 가능하다.
  - 동적으로 할당된 객체를 초기화할 수 있다.
    - 생성자를 자동으로 호출한다.
  - malloc.h나 stdlib.h를 포함할 필요 없다. 

​     

​    

* 실습 5-3: 하나의 정수에 대한 메모리 할당과 해제 : 정적 vs. 동적

```c++
#include <iostream>
int main()
{
 int* pi = new int; // 메모리 할당
 int x;
 if (!pi) { // pi==0, 널 포인터인지 확인
  std::cout << "메모리할당이 되지 않았습니다.";
  return 1; //비정상 종료시 리턴값
 }
 *pi = 100; //주소의 값으로 100을 할당
 x = 10;
 std::cout << "동적메모리=" << *pi << ", x=" << x;
 delete pi; // 메모리 해제
 return 0; // 정상 종료시 리턴값
}
```

   

​    

* Variable-length Array : 실행 가능?

```c++
#include <iostream>
int main()
{
 int i;
 std::cout << "몇 개==";
 std::cin >> i;
 int num[i]; //원래 C표준에서 배열의 크기는 컴파일시 결정되어야 함
 return 0;
}
```

- - C99부터 가변 길이 배열(Variable-length Array) 가능
  - C++ 표준에서는 잠깐 가능했지만 지금은 불가능
    - 표준은 아니지만 온라인 컴파일러에서는 대부분 가능, 하지만 비추
    - Visual Studio에서는 불가능
  - stack overflow가 발생할 수 있으므로 사용하지 않는 것이 좋음



​    

​    

* 실습 5-4: 동적메모리 할당(필요한 만큼의 메모리만 실행시 할당)

```c++
#include <iostream>
#include <stdlib.h> //exit(1)
int main()
{
 int i, n;
 int* num;
 std::cout << "몇 개의 숫자를 입력하시겠습니까==";
 std::cin >> i;
 num = new int[i];
 if (num == NULL) exit(1); //종료
 for (n = 0; n < i; n++)
 {
  std::cout << "숫자를 입력하십시오 : ";
  std::cin >> num[n];
 }
 std::cout << "당신이 입력한 숫자는: ";
 for (n = 0; n < i; n++)
  std::cout << num[n] << ", ";
 delete[] num; //[]을 생략하면?
 return 0;
}
```

​    

​    

* 실습 5-5: 객체 동적할당

```c++
#include <iostream>
class Dog {
private:
 int age;
public:
 int getAge();
 void setAge(int a);
};
int Dog::getAge()
{
 return age;
}
void Dog::setAge(int a)
{
 age = a;
}
int main()
{
 Dog* dp;
 dp = new Dog; // Dog *dp=new Dog
 if (!dp) {
  std::cout << "메모리할당 불가!";
  return 1;
 }
 dp->setAge(5);
 std::cout << "메모리에 할당된 값은 "
  << dp->getAge() << "입니다.";
 delete dp;
 return 0;
}
```

   

​    

* 실습 5-6: 배열객체 동적 할당

```c++
#include <iostream>
class Dog {
private:
 int age;
public:
 int getAge();
 void setAge(int a);
};
int Dog::getAge()
{
 return age;
}
void Dog::setAge(int a)
{
 age = a;
}
int main()
{
 Dog* dp;
 dp = new Dog[10]; // 객체배열 할당
 // Dog *dp=new Dog[10];
 if (!dp) {
  std::cout << "메모리할당이 되지 않았습니다.";
  return 1;
 }
 for (int i = 0; i < 10; i++) // C++에서는 가능
  dp[i].setAge(i);
 for (int i = 0; i < 10; i++)
  std::cout << i << "번째 객체의 나이는 " <<
  dp[i].getAge() << " 입니다. " << std::endl;
 delete[]dp;
 return 0;
}
```

   

* 실습과제

  - 지난주 Cat 클래스에 const 추가하고 주석 달기

  - 동적 메모리를 할당하는 이유와 방법

    - 지역 변수는 자신의 지역({ }) 내에서만 유효한데, 전역변수처럼 프로그램이 끝날 때까지 값을 유지하고 싶은 경우
    - 프로그램 작성시(컴파일시)는 필요한 메모리 공간의 크기를 모르겠고, 프로그램을 실행할 때(runtime) 메모리의 양을 결정해야 하는 경우
      - 사용자 입력에 필요한 메모리 공간을 확보하는 경우
    - 지금까지는 프로그램을 실행하기 전에 고정된 크기를 가지도록 변수, 배열, 객체를 선언
      - int x[1000]; //크기는 넉넉하게
      - 그러나 지역 변수가 저장되는 스택은 한정되어 있어서 너무 큰 크기는 할당 어려움
      - 스택 공간이 부족하면 stack overflow 오류
      -  heap에 할당해야 함
      - 메모리를 할당할 때 new를 사용
      - 할당된 메모리를 해제할 때 delete를 사용

  - 지난주 Cat 클래스에 Cat형 배열 객체 동적으로 할당

    ```c++
    #define _CRT_SECURE_NO_WARNINGS
    #include <iostream>
    #include <string>
    using std::cout;
    class Cat {
    private: //생략가능
     int age;
     std::string name;
    public:
     Cat() {
      age = 5;
      name = "coco";
      cout << name << "고양이 객체가 만들어졌어요.\n";
     }
     ~Cat() { cout << name << "객체 바이\n"; };
     int getAge() const /* const */;
     std::string getName() const /* const */;
     void setAge(int age);
     void setName(std::string pName);
     void meow() const /* const */;
    };
    int Cat::getAge() const /* const */ {
     return age;
    }
    void Cat::setAge(int age) {
     this->age = age;
    }
    void Cat::setName(std::string pName) {
     name = pName;
    }
    std::string Cat::getName() const /* const */ {
     return name;
    }
    void Cat::meow() const /* const */ {
     cout << name << "고양이가 울어요\n";
    }
    int main() {
     Cat *pCat;
     pCat = new Cat[10];
     for (int i = 0; i < 10; i++) // C++에서는 가능
      pCat[i].setAge(i);
     for (int i = 0; i < 10; i++) // C++에서는 가능
      cout << pCat[i].getAge();
     delete [] pCat;
     return 0;
    }
    ```





****** [Week7](https://jhm0919.github.io/Week7/)

 14 minute read

# 7주차 정리[Permalink](https://jhm0919.github.io/Week7/#7주차-정리)

- 변수와 배열
  - 변수
    - 단독주택
    - int x; //4byte짜리 단독주택 1가구
  - 배열
    - 같은 평수로 구성된 아파트
    - int x[5]; //4byte짜리 5가구
- 일차원 배열
  - 배열명 다음에 구두점 대괄호([])를 쓰며 대괄호 안에 배열의 크기를 나타내는 수를 하나 씀
    - 첨자(subscript) 또는 인덱스(index)
  - 자료형 배열명[첨자];
  - int score[7];
    - 배열명 만드는 규칙은 변수명 만드는 규칙과 동일
    - 배열 선언문에서 사용하는 첨자는 양의 정수이며 배열의 크기
    - score배열은 정수형 자료 7개를 저장할 수 있음
    - 7개의 공간을 배열의 원소(element)라 함
- 배열 원소 예

```
#include <stdio.h>
int main(void)
{
 int num[3]; //배열 선언시 첨자의 값은 배열의 크기
 num[0] = 10; //배열 원소(element)의 첨자는 순서
 num[1] = 20;
 num[2] = 30;
 printf("%d, %d, %d ", num[0], num[1], num[2]);
 return 0;
}
```

- 일차원 배열 초기화
  - 일차원 배열 초기화 방법
    - int score[5]={10,20,30,40,50}; //int x = 10;
    - 변수 초기화와 달리 원소가 많으므로 중괄호({})로 묶어 줌
    - score[0]에는 10이, score[1]에는 20 등이 차례대로 초기화됨
  - 문자형 배열 초기화 방법
    - char name[ ]={‘H’,’a’,’n’,’ ‘,’S’,’ ‘,’H’,’\0’};
    - 배열 선언과 함께 초기화까지 할 경우 원소의 개수 8은 생략 가능
    - 문자 배열의 마지막 원소는 반드시 널(NULL) 문자인 ‘\0’
    - 문자형 배열은 문자열과 관련이 있는데 C 언어에서 문자열은 항상 널 문자로 끝나기 때문
  - 문자 배열은 문자열 형태로 초기화할 수도 있음
    - char name[ ]=”Han S H”;
    - 널 문자가 자동으로 마지막 원소에 할당됨
    - 원소의 개수는 8개



- 배열의 초기화

```
#include <stdio.h>
int main(void)
{
 int score[5] = { 10,20,30,40,50 };
 char name[] = { 'H','a','n' ,' ','S',' ','H', '\0' };
 char name1[] = "Han S H";
 printf("%d %d %d\n", score[0], score[1], score[4]);
 printf("%c%c%c%c%c\n", name[1], name[7], name[0], name[3], name[0]);
 printf("%c%c%c%c%c\n", name1[1], name1[7], name1[0], name1[3], name1[0]);
 return 0;
}
```

- 배열 초기화 방법

  - 배열 원소가 초기화 데이터 수보다 많으면 나머지 원소들은 0으로 초기화됨

  - 100개의 원소를 갖는 배열을 2개만 초기화하면 나머지 98개는 모두 0으로 자동 초기화

    - int han[100]={10,20}

  - 배열 원소의 수가 초기화한 데이터 수보다 적으면 “초기화 데이터가 너무 많다”는 에러가 발생

    - int han[2]={10,20,30}
    - error C2078: 이니셜라이저가 너무 많습니다.

  - 배열을 선언과 동시에 초기화한 경우와, 선언 먼저하고 값을 대입한 경우인데 각 원소에는 같은 값이 할당됨

    - int han[3]={10,20,30}; // 배열 선언과 초기화

    - int han[3]; // 배열 선언

      han[0]=10; // 대입

      han[1]=20; // 대입

      han[2]=30; // 대입



- 배열의 초기화

```
#include <stdio.h>
int main(void)
{
 int han[10] = { 10,20 };
 int han2[10] = { 0 };
 printf("%d %d %d %d\n", han[0], han[1], han[2], han[9]);
 printf("%d %d %d\n", han2[0], han2[1], han2[9]);
 return 0;
}
```

- 배열의 초기화와 대입

```
#include <stdio.h>
int main(void)
{
 int han[10] = { 10,20 };//초기화
 int x = 10;
 printf("%d %d %d %d\n", han[0], han[1], han[2], han[9]);
 x = 20;
 han[0] = 1; // 대입
 han[1] = 2; // 대입
 han[2] = 3; // 대입
 printf("%d %d %d %d\n", han[0], han[1], han[2], han[9]);
 return 0;
}
```



- 일차원 배열의 이름 : 배열의 시작주소

```
#include <stdio.h>
int main(void)
{
 int i;
 int han1[3] = { 10,15 };
 int han2[3];
 for (i = 0; i < 3; i++)printf("han1[%d]=%d 주소=%p\n", i, han1[i], &han1[i]);
 printf("han1=%p\n", han1); //&han1[0]
 han2[0] = 10;
 han2[1] = 20;
 han2[2] = 30;
 for (i = 0; i < 3; i++)printf("han2[%d]=%d 주소=%p\n", i, han2[i], &han2[i]);
 printf("han2=%p\n", han2); //&han2[0]
 return 0;
}
```

- 일차원 배열 활용

1.

```
#include<stdio.h>
int main(void)
{
 int i, sum = 0;
 int score[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9,10 };
 for (i = 0; i < 10; i++) sum = sum + score[i];
 printf("평균=%f\n", sum / 10.);
 return 0;
}
```

2.

```
#include<stdio.h>
int main(void)
{
 int sum;
 int s1 = 1, s2 = 2, s3 = 3, s4 = 4, s5 = 5;
 int s6 = 6, s7 = 7, s8 = 8, s9 = 9, s10 = 10;
 sum = s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8 + s9 + s10;
 printf("평균=%f\n", sum / 10.);
 return 0;
}
```

- 다차원 배열

  - 다차원 배열은 2차원 배열, 3차원 배열 등 n차원 배열이 가능

  - 일반적으로 3차원 이상의 배열은 이해하기 어려워서 잘 사용하지 않음

    - int x[3]; // 1차원 배열
    - int x[4][3]; // 2차원 배열, int x[3]이 4개
    - int x[5][4][3]; // 3차원 배열, int x[4][3]이 5개

  - 차원 배열 x의 초기화는 두 가지 방법

    - int x[3][2]={1,2,3,4,5,6};

    - int x[3][2]={ {1,2},

      {3,4},

      {5,6} };

  - 2차원 배열도 물리적으로는 1차원적으로 저장

  - 배열의 전체 크기는 선언시 사용한 첨자를 곱(3x2)하면 되고 마지막 원소는x[3][2]가 아니라 x[2][1]인 것을 명심



- 2차원 배열의 초기화

```
#include <stdio.h>
int main(void)
{
 int x[2][3] = { 10,20,30,40,50,60 };
 printf("%d %d %d\n", x[0][0], x[0][1], x[0][2]);
 printf("%d %d %d\n", x[1][0], x[1][1], x[1][2]);
 return 0;
}
```



- 2차원 배열의 초기화와 대입

```
#include <stdio.h>
int main(void)
{
 int x[2][3] = { 10,20,30,40,50,60 };
 printf("%d %d %d\n", x[0][0], x[0][1], x[0][2]);
 x[0][0] = 1; x[0][1] = 2; x[0][2] = x[0][0];
 printf("%d %d %d\n", x[0][0], x[0][1], x[0][2]);
 x[1][0] = x[0][0] + 1;
 x[1][1] = x[0][0] + x[0][1];
 x[1][2] = x[1][0] * x[1][1];
 printf("%d %d %d\n", x[1][0], x[1][1], x[1][2]);
 return 0;
}
```



- 2차원 배열을 일차원 배열처럼 사용

```
#include <stdio.h>
int main(void)
{
 int i, j;
 int han[2][3] = { 10,20,30,40,50,60 };
 for (i = 0; i < 2; i++) for (j = 0; j < 3; j++)
  printf("han[%d][%d]=%d 주소=%p\n", i, j, han[i][j], &han[i][j]);
 printf("han=%p\n", han); //첫 번째 원소의 주소
 printf("han[0]=%p\n", han[0]); //han[0]으로 시작하는 원소의 시작 주소
 printf("han[1]=%p\n", han[1]); //han[1]로 시작하는 원소의 시작 주소
 return 0;
}
```



- 문자열과 문자형 배열
  - 문자열(string)은 두 개 이상의 문자 묶음
  - 문자열 상수는 문자열 양쪽을 큰 따옴표(“ “)로 감싸야 함
- abc는 “abc”
- 대한민국은 “대한민국”
  - 문자열 상수는 각 문자가 한 바이트 씩 저장되므로 문자열 “ABC”는 ASCII코드 값(65 66 67 0)에 해당하는 2진수로 메모리에 저장됨
  - 문자열은 문자형 배열에 두 가지 방법으로 초기화할 수 있음
    - char eng[4]={‘A’, ‘B’, ‘C’,’\0’} // 문자의 모임
    - char eng[4]=”ABC”; // 문자열
  - 문자열 상수에서는 문자열의 끝을 의미하는 널 문자가 제일 뒤에 자동적으로 붙여짐
  - ‘a’는 문자로 1바이트에 저장되고, “a”는 문자열로 뒤에 널 문자가 있으므로 2바이트에 저장됨



- 문자형 배열 초기화 방법

```
#include <stdio.h>
int main(void)
{
 int i;
 char st[] = "soft";
 char ch[] = { 's', 'o', 'f', 't', '\0' };
 for (i = 0; i < 5; i++)printf("st[%d] 주소 %p =%c\n", i, &st[i], st[i]);
 for (i = 0; i < 5; i++)printf("ch[%d] 주소 %p =%c\n", i, &ch[i], ch[i]);
 return 0;
}
```

- 문자형 배열 초기화와 배열명

```
#include <stdio.h>
int main(void)
{
 char eng[5] = "A BC";
 char kor[6] = "하이a";
 printf("%p:%c ", eng, eng[0]);
 printf("%p:%c ", eng + 1, eng[1]);
 printf("%p:%c ", eng + 2, eng[2]);
 printf("%p:%c ", eng + 3, eng[3]);
 printf("%p:%c\n", eng + 4, eng[4]);
 printf("%s\n", eng); //char형 배열 문자열을 출력하려면 배열의 이름을 %s로 출력하면 된다.
 printf("%p:%c ", kor, kor[0]);
 printf("%p:%c ", kor + 1, kor[1]);
 printf("%p:%c ", kor + 2, kor[2]);
 printf("%p:%c ", kor + 3, kor[3]);
 printf("%p:%c ", kor + 4, kor[4]);
 printf("%p:%c\n", kor + 5, kor[5]);
 printf("%s\n", kor);
 return 0;
}
```



- 이름을 입력받아 출력하는 프로그램

```
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
int main(void)
{
 char name[10];
 printf("당신의 이름을 입력하세요=");
 //scanf("%s", name); 
 gets_s(name);//와 차이점?
 printf("당신의 이름은 %s입니다.\n", name);
 return 0;
}
```



- 5개의 이름을 입력받아 출력하는 프로그램

```
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
int main(void)
{
 int i;
 char name[5][10];
 for (i = 0; i < 5; i++)
 {
  printf("당신의 이름을 입력하세요=");
  scanf("%s", name[i]);
 }
 for (i = 0; i < 5; i++)
  printf("당신의 이름은 %s입니다.\n", name[i]);
 return 0;
}
```



- 배열 복사는 strcpy() 사용

visual studio

```
#define _CRT_SECURE_NO_WARNINGS //Visual Studio의 경우
#include <iostream>
#include <string> //or string.h(clang++, gcc 등 주로 온라인 컴파일러)
int main(void)
{
 char s1[5];
 char s2[5] = "soft"; //원본
 //s1 = s2; //error C3863: 배열 형식 'char [5]'은(는) 할당할 수 없습니다.
 strcpy(s1, s2); //s2주소의 문자열을 널 문자를 만날 때까지s1주소로 복사
 std::cout << "s1=" << s1 << " s2=" << s2 << std::endl;
 return 0;
}
```

online compiler

```
#define _CRT_SECURE_NO_WARNINGS //Visual Studio의 경우
#include <iostream>
#include <string.h> //or string.h(clang++, gcc 등 주로 온라인 컴파일러)
int main(void)
{
 char s1[5];
 char s2[5] = "soft"; //원본
 //s1 = s2; //error C3863: 배열 형식 'char [5]'은(는) 할당할 수 없습니다.
 strcpy(s1, s2); //s2주소의 문자열을 널 문자를 만날 때까지s1주소로 복사
 std::cout << "s1=" << s1 << " s2=" << s2 << std::endl;
 return 0;
}
```

- 저장될 공간의 크기를 지정하는 안전한 strcpy_s()

```
#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 1
#include <iostream>
#include <string>
using std::cout;
int main(void)
{
 char s1[5];
 char s2[5] = "soft"; //원본
 strcpy(s1, s2);
 // strcpy_s(s1,5,s2);
 cout << "s1=" << s1 << " s2=" << s2;
 return 0;
}
```

- 실습 4-1 : 고양이 클래스 (1)

```
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <string> //string.h
using std::cout;
class Cat {
private: //생략가능
 int age;
 char name[20]; // A
 //const char *name; //B, 비추
public:
 int getAge();
 const char* getName();
 void setAge(int a);
 void setName(const char* pName);
};
int Cat::getAge()
{
 return age;
}
void Cat::setAge(int a)
{
 age = a;
}
void Cat::setName(const char* pName)
{
 strcpy(name, pName); //A
 //name=pName; //B, 주소 대입
}
const char* Cat::getName()
{
 return name;
}
int main()
{
 Cat nabi;
 nabi.setName("나비");
 nabi.setAge(3); //입력
 cout << nabi.getName() << " 나이는" << nabi.getAge() << "살이다.";
 return 0;
}
```

- 고양이 클래스 (2)

```
#define _CRT_SECURE_NO_WARNINGS 
#include <iostream>
#include <string>
using namespace std; //C
class Cat {
private: //생략가능
 int age;
 string name; // C
public:
 int getAge();
 string getName();
 void setAge(int a);
 void setName(string pName);
};
int Cat::getAge()
{
 return age;
}
void Cat::setAge(int a)
{
 age = a;
}
void Cat::setName(string pName)
{
 // strcpy(name, pName); 
 name = pName; //C
}
string Cat::getName()
{
 return name;
}
int main()
{
 Cat nabi;
 nabi.setName("나비");
 nabi.setAge(3); //입력
 cout << nabi.getName() << " 나이는" << nabi.getAge() << "살이다.";
 return 0;
}
```



- 실습 4-2 : 객체 배열

```
#include <iostream>
using std::cout;
class Dog {
private:
 int age;
public:
 int getAge() { return age; } //자동 inline함수
 void setAge(int a) { age = a; } //자동 inline함수
};
int main()
{
 int i;
 Dog dd[5]; //Dog클래스형 객체배열 dd, 강아지 5마리
 for (i = 0; i < 5; i++) {
  dd[i].setAge(i);
  cout << dd[i].getAge(); //01234
 }
 return 0;
}
```

- 실습 4-3 : 포인터 객체

```
#include <iostream>
using std::cout;
class Dog {
private:
 int age;
public:
 int getAge() { return age; }
 void setAge(int a) { age = a; }
};
int main()
{
 Dog happy, * pd; //일반 객체 happy와 포인터 객체 pd, int x, *px;
 pd = &happy; //px=&x;
 happy.setAge(5); //일반 객체는 '.'으로 멤버를 접근
 cout << pd->getAge(); //포인터 객체는 '->'로 멤버를 접근
 return 0;
}
```



- 실습4-4 : 객체 배열과 포인터

```
#include <iostream>
using std::cout;
class Dog {
private:
 int age;
public:
 int getAge() { return age; }
 void setAge
 (int a) {age = a;}
};
int main() {
 Dog dd[5];
 Dog* pd;
 pd = dd; //배열의 이름은 그 배열의 시작주소이다.
 for (int i = 0; i < 5; i++) {
  pd->setAge(i);
  cout << dd[i].getAge();
  cout << pd->getAge();
  pd++; //다음 방의 주소로
 } //0011223344
 return 0;
}
```

- 생성자(constructor)
  - “int a=5;”라는 명령에서 일어나는 작업은?
    - 정수형 기억장소 4바이트를 메모리에 할당하고, 그곳에 5라는 값으로 초기화를 하라.
  - 일반 자료형(int, float, char 등)의 경우 컴파일러가 알아서 처리해 주지만 사용자 정의형인 클래스는 어떻게 해당 객체를 초기화하나?
  - 이런런 작업을 담당하는 함수가 바로 생성자이다.
  - 생성자는 사용자가 특별히 지정하지 않아도 자동으로 호출되지만 멤버에 대한 초기화 자료를 지정하지 않으면 객체 멤버변수들은 쓰레기(garbage)값을 갖는다.
  - 즉, 생성자는 주로 멤버변수의 초기화를 한다.



- 초기화

  - 변수의 초기화

    - int num=5;
    - char ch=’A’;
    - double avg=0.0;
    - int *pnum=&num;
    - char *name=”Han”;

  - 배열의 초기화

    - int sd[3]={1,2,3};
    - char name[4]={‘H’,’a’,’n’,’\0’};

  - 구조체 변수(객체)의 초기화

    - struct SCORE{

      char name[15];

      int kor;

       };

       struct SCORE h={“하니”,90};

  - Dog클래스의 객체 초기화?

    - 생성자를 만들어 사용



- 생성자의 특징
  - 생성자의 이름은 클래스명과 같다.
    - 클래스명이 Dog라면 생성자 이름은 Dog()
  - 클래스의 객체가 생성될 때마다 자동으로 호출된다.
  - 보통 객체가 메모리에 할당될 때 멤버변수의 초기화를 담당한다.
  - 리턴형을 쓰지 않는다.
    - 리턴값이 존재하지 않으며 void형을 지정해도 안된다.
    - C/C++언어에서는 리턴값을 생략하면 int형인데 생성자는 예외이다.
  - 생성되는 객체마다 초기화 값이 다를 수 있으므로 하나의 클래스에 여러 개의 생성자가 존재할 수 있다.
    - 매개변수는 달라야한다. (함수 중첩(overloading)에서 자세히 설명함)
  - 객체가 생기면서 자동 호출되며, 사용자가 호출할 수는 없다.
  - 생성자가 반드시 있어야 하는 것은 아니지만 메모리를 초기화 한다는 의미에서 있는 것이 좋다.
    - new에서 설명



- 실습 4-5 : private멤버변수를 특정 값으로 초기화하는 생성자

```
#include <iostream>
using std::cout;
class Dog {
private:
 int age;
public:
 Dog() { age = 1; } // 생성자 정의, Dog():age(1){ }, Dog():age{1}{ } 
 int getAge() { return age; }
 void setAge(int a) { age = a; }
};
int main()
{
 Dog happy; //happy객체가 생성되는 순간 생성자가 자동 호출됨
 cout << happy.getAge();
 return 0;
}
#include <iostream>
using std::cout;
class Dog {
private:
 int age;
public:
 Dog(); // 생성자 선언
 int getAge();
 void setAge(int a);
};
Dog::Dog() // 생성자 정의, 리턴형을 쓰면 안됨
{
 age = 1; // private멤버변수 Age를 초기화
}
int Dog::getAge()
{
 return age;
}
void Dog::setAge(int a)
{
 age = a;
}
int main()
{
 Dog happy; //happy객체가 생성되는 순간 생성자가 자동 호출됨
 cout << happy.getAge();
 return 0;
}
```

- C++에서 변수를 초기화하는 방법

```
#include <iostream>
int main()
{
 int x = 1; //copy initialization,비추
 int y(2);//direct initialization
 int z{3};//Uniform initialization, C++11
 int z1{};//Uniform initialization, 자동으로 0,C++11
 std::cout << x << y << z << z1;
}
```



- 실습 4-6 : 생성자의 매개변수로 멤버변수 초기화

1.

```
#include <iostream>
using std::cout;
class Dog {
private:
 int age;
public:
 Dog(int a) {
  age = a;
 }
 int getAge() { return age; }
 void setAge(int a) { age = a; }
};
int main()
{
 Dog coco(4); //4는 생성자로 넘어감
 Dog coco1{ 3 };//Uniform initialization
 Dog coco2 = Dog(2); //비추
 Dog coco3 = 1; //비추
 cout << coco.getAge() << coco1.getAge() << coco2.getAge() << coco3.getAge();
 return 0;
}
```



2.

```
#include <iostream>
using std::cout;
class Dog {
private:
 int age;
public:
 Dog(int a) :age(a) {} //initializer list
 // Dog(int a):age{a}{}
 int getAge() { return age; }
 void setAge(int a) { age = a; }
};
int main()
{
 Dog coco(4); //4는 생성자로 넘어감
 Dog coco1{ 3 };//Uniform initialization
 Dog coco2 = Dog(2); //비추
 Dog coco3 = 1; //비추
 cout << coco.getAge() << coco1.getAge() << coco2.getAge() << coco3.getAge();
 return 0;
}
```

3.

```
#include <iostream>
using std::cout;
class Dog {
private:
 int age;
public:
 //Dog(int a) :age(a) {} //initializer list
  Dog(int a):age{a}{}
 int getAge() { return age; }
 void setAge(int a) { age = a; }
};
int main()
{
 Dog coco(4); //4는 생성자로 넘어감
 Dog coco1{ 3 };//Uniform initialization
 Dog coco2 = Dog(2); //비추
 Dog coco3 = 1; //비추
 cout << coco.getAge() << coco1.getAge() << coco2.getAge() << coco3.getAge();
 return 0;
}
```

- 소멸자 (destructor)
  - 클래스의 객체가 소멸될 때 자동으로 호출된다.
  - 소멸자의 이름은 클래스명과 같고, 앞에 ~(tilde)를 붙인다.
  - 클래스명이 Dog라면 소멸자 이름은 ~Dog()
  - 하나의 클래스에 유일하다.
    - 생성자는 중첩이 가능하지만 소멸자 중첩은 불가능하다.
  - 리턴형과 매개변수가 없다.
    - 리턴값이 존재하지 않으며 void형을 지정해도 안된다.
    - ~Dog();
  - 사용자가 직접 호출할 수는 없다.





- 소멸자의 용도
  - 객체가 소멸될 때 자동으로 호출되므로 객체가 소멸될 때 하고싶은 코드를 작성한다.
  - 소멸자는 사용한 메모리 공간이 더 이상 불필요하게 될 때 해당메모리를 시스템이나 다른 객체에 반납하는 용도로 많이 사용하는 함수이다.
    - delete 참조
    - 한 객체가 사용한 메모리 공간을 해제하지 않으면 해당 공간은 다른프로그램에서 사용할 수 없다.



- 실습 4-7 : 객체가 소멸되면서 “소멸”이라고 출력되는 소멸자

```
#include <iostream>
using std::cout;
class Dog {
private:
 int age;
public:
 Dog(int a) { age = a; cout << "멍\n"; }
 ~Dog() { cout << "소멸\n"; }
 // 소멸자 정의
 int getAge();
 void setAge(int a);
};
int Dog::getAge()
{
 return age;
}
void Dog::setAge(int a)
{
 age = a;
}
int main()
{
 Dog happy(5);
 cout << "main함수 시작\n";
 cout << happy.getAge();
 cout << "\nmain함수 끝\n";
 return 0;
}
```

- this 포인터
  - this 포인터는 자동적으로 시스템이 만들어 주는 포인터
  - 멤버가 호출될 때 그 멤버가 속한 객체를 가르킨다.
  - 객체를 통하여 멤버를 호출할 때 컴파일러는 객체의 포인터 즉 주소를 this포인터에 넣은 다음 멤버를 호출한다.
  - this 포인터는 멤버를 호출한 객체의 const 포인터이다.
  - 멤버함수를 수행하고 나서 그 결과로 객체 자신을 되돌릴 경우 return *this라고 하면 된다.
  - 멤버함수에서 볼 때 this 포인터는 어떤 객체가 자신을 호출했는지 알고자 하는 경우 사용한다.
  - 연산자 중첩에서 사용
  - 클래스의 멤버함수 내에서 다른 클래스에 자기 자신을 매개변수로 넘길 때 사용



- 실습 4-8 : this 포인터 예 1

```
#include <iostream>
using std::cout;
class Dog {
private:
 int age;
public:
 Dog(int a) { age = a; }
 ~Dog() { cout << "소멸"; }
 int getAge();
 void setAge(int a);
};
int Dog::getAge()
{
 return age;
}
void Dog::setAge(int a)
{
 age = a;
}
int main()
{
 Dog happy(5);
 cout << happy.getAge();
 return 0;
}
```

- 실습 4-9 : this 포인터 예 2

```
#include <iostream>
using std::cout;
using std::endl;
class Dog {
private:
 int age;
public:
 Dog(int a);
 ~Dog();
 int getAge();
 void setAge(int a);
};
Dog::Dog(int a)
{
 age = a;
 cout << this << endl;
}
Dog::~Dog()
{
 cout << "소멸";
}
int Dog::getAge()
{
 return age;
}
void Dog::setAge(int a)
{
 age = a;
}
int main()
{
 Dog happy(5), meri(3);
 cout << happy.getAge();
 cout << meri.getAge();
 return 0;
}
```

- 과제

- Cat 클래스를 구현하시오.

- 나이, 몸무게, 이름을 private 멤버 변수로 갖고, 이것들을 매개변수로 받아들여 초기화할 수 있는 생성자와, “소멸”이라고 출력하는 소멸자를 갖는다.

- private 멤버변수에 접근(입/출력)하기 위한 범용 접근자 함수(getXX, setXX)를 구현하시오.

- 또한 고양이의 특성을 나타내는 멤버함수들도 지정하시오. 예를 들어 다음과 같은 멤버함수가 가능하다.

- void Cat::meow()

  {

  cout« “야옹.\n”;

  }

- this포인터도 사용해 보시오.

- Cat형 객체를 만들어서 테스트

```
#include <iostream>
#include <fstream>
#include <string>
using namespace std;
class Cat {
private:
 int age;
 double weight;
 string name;
public:
 Cat(int a, double b, string c)
 {
  this->age = a, weight = b, name = c; cout << "야옹~\n" << this << endl;
 }
 ~Cat() { cout << "소멸"; }
 int getAge() { return this->age; }
 void setAge(int a) { this->age = a; }
 double getWeight() { return weight; }
 void setWeight(double b) { weight = b; }
 string getName() { return name; }
 void setName(string c) { name = c; }
 void meow();
};
void Cat::meow()
{
 cout << "야옹..\n"; 
}
int main()
{
 Cat cat(5, 5.5, "coco");
 cout << "고양이 나이는 : " << cat.getAge() << "살\n" << "몸무게는 : " << cat.getWeight() << "kg\n"  << "이름은 : " << cat.getName() << endl;
 return 0;
}
```





###### ‘C++프로그래밍(21-2학기)한성현교수 강의 내용 변형 및 요약’

