# 15주차 정리

*  입출력 객체(I/O stream object)
   *  C에서는 printf(), scanf() 함수를 이용하여 콘솔(console) 입출력을 처리하였다. 
   *  이 함수들의 원형은 표준헤더 stdio.h에 정의되어 있으며 C++에서도 그대로 사용할 수 있다. 
   *  그러나 C++에서는 객체지향 개념을 사용하는 새로운 입출력 내장함수를 제공하고 있다.
   *  이를 "입출력 객체(I/O stream object)" 또는 "입출력 스트림(I/O stream)"이라 한다.
   *  입출력 스트림은 텍스트로 된 문자열과 데이터 타입을 가지는 객체 사이에서 데이터 변환 작업을 자동으로 수행한다. 

​    

​    

​    

​    

*  입출력 객체 스트림
   *  객체란 데이터에 대한 처리를 스스로 할 수 있는 단위
   *  사용자가 처리하고자 하는 데이터에 대한 %d, %c, %f, %s 등의 구체적인 서식을 지정하지 않아도 자동 변환되므로 표준 입출력 객체를 사용하면 보다 편리하게 프로그래밍할 수 있다. 
   *  그래서 객체지향 프로그래밍을 하기 위해서는 기존의 함수보다 이러한 입출력 객체 스트림을 이용하는 것이 좋다.

​    

​    

​    

​    

​    

* 입/출력 스트림 객체

  * 입력 스트림 객체인 cin은 삽입연산자(insertion operator) ">>"를 사용하여 데이터를 입력받아 변수를 저장한다.

  * 출력 스트림 객체 cout은 추출연산자(extraction operator) "<<"를 이용하여 변수의 내용을 화면에 출력한다. 

  * C에서 이 연산자는 왼쪽과 오른쪽 시프트(shift)연산을 수행한다. 

  * C++에서도 그 연산의 본래 의미도 남아 있지만 연산자 중첩에 의하여 입력과 출력을 수행하는 확장된 역할까지 겸하고 있다. 

  * 입출력 객체를 사용하기 위해서는 전처리기 지시자 "#include"문을 사용하여 <iostream>를 프로그램에 포함시켜야 한다. 

  * 콘솔에 출력 ☞ cout<<변수명(값);

  * 콘솔로부터 입력 ☞ cin>>변수명;

    

​    

​    

​    

​    

* 입출력 객체의 장점

  * 입출력 객체는 표준 입출력 함수보다 훨씬 간단한 방법으로 사용한다.

  * scanf() 함수에서는 입력 데이터의 형식을 지정하고 입력 장소에 대한 주소를 대상 데이터로 전달해야 했지만 cin 객체는 서식 지정이 필요 없고 입력 장소 또한 주소가 아니라 변수 자체를 대상으로 한다. 

    *  scanf("%d",&x);
    *  std::cin >> x;

  * C++에서는 입출력을 담당하는 스트림(stream) 클래스들이 클래스 라이브러리를 형성하여 이들을 이용하면 매우 편리하다.

  * 입출력은 일반 객체들과 동일한 객체들(스트림 객체)로 정의되어 있어 동작 메카니즘이나 형이 다른 기능들과 일관성을 유지한다. 

    

    

​    

​    

​    

​    

​    

​    

* 스트림의 역할

  * 스트림은 프로그램에 필요한 데이터를 입력받거나 또는 프로그램에서 생성한 자료를 출력하기 위해 C++ 입출력 시스템에서 물리적 입출력 장치를 논리적 입출력으로 정의한 것이다. 

  * 모든 스트림은 그것이 표현하는 물리적 입출력 장치와 관계없이 동일한 방법으로 동작한다. 

  * 즉 스트림은 컴퓨터의 입출력장치와 프로그램 사이의 인터페이스의 역할을 한다.

     

​    

​    

​    

​    

​    

​    

* ios 클래스

  * istream 클래스는 입력 작업에 필요한 기능들이 정의되어 있는 클래스

  * ostream 클래스는 출력 작업에 필요한 기능들이 정의되어 있는 클래스

  * iostream은 istream과 ostream으로부터 다중 상속된 파생클래스로 입력과 출력 모두를 제공하는 양방향 스트림

  * ifstream, ofstream, fstream은 파일 입출력 작업을 다루는 클래스로 파일을 대상으로 한다는 점을 제외하고는 istream, ostream, iostream과 유사

    

​    

​    

​    



​    

*  표준 스트림
   *  C++ 프로그램에서 헤더파일 <iostream>를 포함시키면 다음과 같이 자동으로 열리는 4개의 입출력 스트림 객체가 생성된다. 

​    

​    



​    

​    

* "<<"연산자의 중첩

  * 지금까지 우리는 cout과 "<<"쉬프트 연산자를 이용하여 자료를 출력하였다. 

  * 출력을 할 때 이용하는 클래스는 ostream인데 cout은 이 클래스의 자동 선언된 객체이고, 

    "<<"는 연산자 중첩된 연산자이다. 

  * 즉 "<<"은 아래와 같이 모든 기본 자료형에 대하여 중첩 정의되어 있다.







​    

​    

​    

* 형식 입출력

  * 지금까지의 예제에서는 C++의 디폴트 형식을 이용하여 화면에 정보를 출력하였다. 

  * 그러나 C++에서도 C의 printf() 함수와 유사한 기능을 수행하는 형식(format) 입출력이 가능하다. 

  * C++이 제공하는 ios 클래스를 이용하면 사용자가 입출력 형식을 지정할 수 있는 형식 입출력(formatted I/O)이 가능하다. 

  * C++의 모든 입출력 스트림에는 입출력 형식을 지정하는 형식상태(format state)가 있어서 지정된 형식상태에 따라 입출력 동작을 수행한다. 

  * 형식상태는 비트 형태로 표현되는 형식 플래그(format flag) 값에 의해 그 의미가 지정된다. 

  * 즉 특정 비트의 값이 0이냐 1이냐에 따라 입출력 형식이 지정된다. 

  * 형식 플래그는 ios 클래스 내부에 열거형으로 정의되어 있다.

    

​    

​    

​    

​    

​    

* ios 형식 플래그 설정 및 참조 멤버함수

  * long setf(long f); // 플래그 세트 함수

    *  형식 플래그를 인수로 받아서 이 플래그 값에 해당하는 비트의 필드를 세트(1) 시키는 함수

  * long unsetf(f); // 플래그 클리어 함수

    *  setf(f) 함수와 반대의 기능을 수행하는 함수로 해당 비트를 클리어 시키는 함수. 
    *  이 함수는 변경되기 이전의 플래그 값을 반환한다.

  * long flags(); // 플래그 참조 함수

    *  현재 플래그의 상태를 반환하는 함수

  * long flags(long f); // 플래그 참조 함수

    *  플래그를 인수 f의 비트 패턴으로 세트시키고 변경되기 이전의 플래그 값을 반환

  * long setf(f1, f2); // 플래그 세트 함수

    * setf(f1, f2) 함수는 f2에 해당하는 비트 필드를 클리어(0) 시킨 다음 f1에 해당하는 비트의 필드를 세트시킴

    * setf(f1, f2) 함수 형식은 서로 배타적인 플래그가 동시에 세트되는 것을 방지하기 위한 것임

    * 두 번째 매개변수 f2의 표현을 지원하고자 ios 클래스에 다음과 같이 자주 사용되는 상수가 정의되어 있음

       

​    

​    

​    

​    

​    

* setf(f1, f2)함수의 f2에 자주 사용되는 상수

  * setf(f1, f2) 함수는 f2에 해당하는 비트 필드를 클리어(0) 시킨 다음 f1에 해당하는 비트의 필드를 세트시킴

  * static const long ios::basefield;

    *  cout.setf( ios::hex, ios::basefield ); //16진수로
    *  ios::dec | ios::oct | ios::hex 

  * static const long ios::adjustfield

    *  cout.setf( ios::right, ios::adjustfield ); //우측 정렬
    *  ios::left | ios::right | ios::internal

  * static const long ios::floatfield

    * cout.setf( ios::fixed, ios::floatfield ); //고정 소수점

    * ios::scientific | ios::fixed

      

​    

​    





​    

* 실습 11-1: setf(),unsetf()예제

  ```c++
  #include <iostream>
  using namespace std;
  int main() {
   cout << "디폴트\n";
   cout << 100 << ':' << -50 << endl; //100: -50
   cout << 0.5 << ':' << 100.123 << endl;//0.5:100.123
   cout.unsetf(ios::dec);
   cout.setf(ios::hex | ios::showbase | ios::uppercase);
   cout << "hex, showbase, uppercase\n";
   cout << 100 << ':' << -50 << endl; //0X64:0XFFFFFFCE
   cout.setf(ios::scientific);
   cout << "scientific\n";
   cout << 0.5 << ':' << 100.123 << endl;//5.000000E-001:1.00123E+002
   cout.unsetf(ios::hex | ios::scientific);
   cout << "hex, scientific unsetting\n";
   cout << 100 << ':' << -50 << endl; //100:-50
   cout << 0.5 << ':' << 100.123 << endl;//0.5:100.123
   return 0;
  }
  ```

  setf() 함수로 세트된 각 플래그의 상태는 unsetf() 함수에 의해 클리어 될 때까지 지속된다.





​    

​    

​    

​    

* 실습 11-2: 형식 설정 멤버함수

  *  ios 클래스에는 플래그의 값을 다루는 멤버함수 이외에 자료의 출력시 폭(width), 정밀도(precision) 등을 설정하는 멤버함수가 제공된다.
  *  int width(int w); 
     *  출력 폭을 w로 지정
  *  int precision(int p); 
     *  소수점을 포함하지 않는 전체 자리수를 p로 지정, 소수점 이하 자리수를 지정하고 싶으면 cout<<fixed를 먼저 지정
  *   int fill(char ch); 
     *  남는 필드의 위치에 ch문자로 채움

  ```c++
  #include <iostream>
  using namespace std;
  int main() {
   cout << "디폴트\n";
   cout.width(10);
   cout << -50 << endl;
   cout << "[ * fill ]\n";
   cout.fill('*');
   cout.width(10);
   cout << -50 << endl;
   cout.width(10);
   cout << 100.25 << endl;
   cout.width(10);
   cout << "HanSH" << endl;
   cout.fill(' ');
   cout.precision(6); //소수점을 제외한 전체 자리수
   cout << 12.34567 << endl;
   cout << fixed; //소수점 이하의 자리수만 다루게 함
   cout.precision(3);
   cout << 12.34567 << endl;
   return 0;
  }
  ```

  • width() 함수의 영향은 일시적이므로 매 출력시마다 지정해 주어야 한다. 

  • fill() 함수는 한번 지정하면 그 효과가 계속 유지된다. 





​    

​    

​    

​    

* 입출력 조절자(I/O manipulator)

  * C++에서는 입출력 조절자(I/O manipulator)라는 함수를 이용한 형식 입출력 기능을 제공한다. 

  * 입출력 조절자는 입출력문의 입출력 연산자와 함께 연속적으로 직접 기술이 가능하다는 이점이 있다. 

  * width() 멤버함수와 같은 기능을 하는 setw() 입출력 조절자가 있는데 입출력 연산자와 함께 사용할 수 있다.

  * cout<<oct<<50<<hex<<50; //50을 8진수로 출력하고, 16진수로 출력

  * cout<<setw(5)<<50 //50을 5칸으로 출력

    *  cout.width(5);
    *  cout << 50;

    

​    

​    

​    

​    

​    

* setiosflags()/ resetiosflags()

  * 앞의 조절자 중에서 setw()같이 매개변수를 갖는 조절자를 사용하는 경우에는 헤더파일 <iomanip>를 포함해야 한다. 

  * 입출력 조절자는 입출력 문장에 함께 있는 스트림에만 영향을 미친다. 

  * 이 조절자를 이용하여 특정한 형식 플래그를 설정하고 싶다면 setiosflags()를 사용한다. 

  * 이 조절자는 setf() 멤버함수와 동일한 기능을 수행한다. 

  * 반대로 플래그를 사용하지 않으려면 resetiosflags()를 사용하며, 이 조절자는 unsetf() 함수와 동일한 기능을 한다.

    

​    

​    

​    

​    

​    

* 실습 11-3: setw()/setfill()

  ```c++
  #include <iostream>
  #include <iomanip>
  using namespace std;
  int main() {
   cout << "abcdefg\n";
   cout << 12345 << endl;
   cout << 123.45 << endl;
   cout << "10칸\n";
   cout << setfill('*');
   cout << setw(10) << "abcdefg" << endl;
   cout << setw(10) << 12345 << endl;
   cout << setw(10) << 123.45 << endl;
   return 0;
  }
  ```

  



​    

​    

​    

​    

​    

* 실습 11-4: setiosflags(ios::left)

  ```c++
  #include <iostream>
  #include <iomanip>
  using namespace std;
  int main()
  {
   cout << 12345 << 67890 << 1234567890 << 1234567890 << 1234567890 << endl;
   cout << "10칸 오른쪽 정렬\n";
   cout << setw(10) << "abcdefg" << setw(10) << "abcdefg";
   cout << setw(10) << 12345 << setw(10) << 12345 << endl;
   cout << setw(10) << 123.45 << setw(10) << 123.45 << endl;
   cout << setiosflags(ios::left);
   cout << "10칸 왼쪽 정렬\n";
   cout << setw(10) << "abcdefg" << setw(10) << "abcdefg";
   cout << setw(10) << 12345 << setw(10) << 12345 << endl;
   cout << setw(10) << 123.45 << setw(10) << 123.45 << endl;
   return 0;
  }
  ```

  

​    

​    

​    

​    

​    

* 파일 입출력

  * 파일을 통한 입출력도 앞의 표준 입출력과 마찬가지로 스트림을 이용하여 입출력 동작이 이루어진다. 

  * 파일 입출력 동작을 수행하기 위하여 정의된 클래스로는 ifstream, ofstream, fstream 클래스가 있으며 이들 클래스는 fstream 헤더파일에 정의되어 있다. 

  * ifstream은 파일로부터의 입력(파일 읽기) 동작을 수행하기 위한 스트림 클래스이고, 

    ofstream은 파일로 출력(파일 쓰기)하기 위한 스트림을 선언하는 클래스이다. 

  * fstream은 입출력 동작 모두를 위한 스트림을 선언할 때 사용된다. 

  * 파일 스트림의 객체는 사용자가 직접 프로그램 상에서 선언해야 하고, 파일을 개방(open)하고 종결(close)하는 동작이 필요하다.

    

    

    

    ​    

​    

​    

* 파일의 개방/종결 형식

  * 파일을 개방하는 2가지 방법

    *  파일클래스 스트림객체명(파일명, 개방모드);

    *  파일클래스 스트림객체명;

       스트림객체명.open(파일명,개방모드); 

  * 파일을 종결하는 방법

    *  스트림객체명.close();

​    

​    

​    

​    

​    

​    

* 실습 11-5: 파일로 출력하기

  ```c++
  #include <iostream>
  #include <fstream>
  using namespace std;
  int main()
  {
   ofstream hout("test.txt"); // 출력파일 스트림 객체 hout 선언
   if (!hout) {
    cout << "출력할 파일을 열 수 없습니다.";
    return 1;
   }
   hout << "Han\n";
   hout << 100 << endl << hex << 100 << endl;
   hout.close(); //파일 종결
   return 0;
  }
  ```

  



​    

​    

​       

​    

* 실습 11-6: 파일로부터 입력받기

  ```c++
  #include <iostream>
  #include <fstream>
  using namespace std;
  int main()
  {
   ifstream hin("test.txt"); // 입력파일 스트림 객체 hin 선언
   if (!hin) {
    cout << "입력할 파일을 열 수 없습니다.";
    return 1;
   }
   char str[50];
   int i, j;
   hin >> str >> i >> j;
   cout << str << " " << i << " " << j << endl;
   hin.close(); // 파일 종결
   return 0;
  }
  ```

  



​    

​    

​    

​    

* 실습 11-7: 파일 입출력을 수행하는 프로그램

  ```c++
  #include <iostream>
  #include <fstream>
  using namespace std;
  int main()
  {
   ofstream hout("test.txt");
   if (!hout) {
    cout << "출력할 파일을 열 수 없음.";
    return 1;
   }
   hout << "Han S. H. \n";
   hout.close();
   ifstream hin("test.txt");
   if (!hin) {
    cout << "입력할 파일을 열 수 없음.";
    return 1;
   }
   char str[50];
   hin >> str;
   cout << str << endl;
   hin.close();
   return 0;
  }
  ```

  Han

  이 예제는 파일 "test.txt"에 Han S. H. 를 출력한 후에 이 파일로부터 문자열을 입력 받는 예이다. 

  첫번째 공백이 나오면 입력을 종료함

  파일의 개방 실패여부는 "!스트림객체명"으로 표시한다.

  예를 들어 파일의 개방이 실패하면 "!hout"식은 참이 된다. 





​    

​    

​    

​    

​    

* 실습 11-8: "test.txt"에 저장된 내용을 읽어들여 공백을 "*"로 채워 화면에 출력

  ```c++
  #include <iostream>
  #include <fstream>
  using namespace std;
  int main()
  {
   char ch;
   ifstream hin("test.txt");
   if (!hin) {
    cout << "입력할 화일을 열 수 없음";
    return 1;
   }
   hin.unsetf(ios::skipws);//공백 무시x
   while (!hin.eof()) {
    hin >> ch;
    if (ch == ' ') ch = '*';
    cout << ch;
   }
   hin.close();
   return 0;
  }
  ```

  공백을 '*'로 대치하여 출력한다. 

  공백문자를 읽어 들이려면 형식 플래그 중 skipws를 클리어시켜야 하는데 이는 표준 입출력과 마찬가지로 unsetf()멤버함수를 사용한다. 

  파일의 끝에 도달했는지를 판단하기 위해 eof()멤버함수를 호출한다. 

  eof()멤버함수는 파일의 끝에 도착하면 참을 반환한다.





​    



###### 'C++프로그래밍(21-2학기)한성현교수 강의 내용 변형 및 요약'

